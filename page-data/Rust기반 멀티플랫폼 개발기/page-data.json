{"componentChunkName":"component---src-templates-post-jsx","path":"/Rust기반 멀티플랫폼 개발기/","result":{"data":{"site":{"siteMetadata":{"title":"sxngt.github.io"}},"markdownRemark":{"id":"5615442b-1aa9-5219-8ad5-d1b7b30bc50d","excerpt":"갑자기 어떤 경위로.. 무슨 Rust를 만지느냐 필자는 보안을 갖다버린 후 Java, Python 이외에는 크게 언어를 만진적이 없다. 심지어 익스또한 파이썬으로 짜기 때문에 읽는 것을 제외하고 작성하는 거셍서는 로우레벨 언어에 대한 애정이 정말 없었다. 하지만 Runtime Language가 주는 화려한 뒷북은 항상 기가막히게 나의 혈압을 올려왔기에 최…","html":"<h1>갑자기 어떤 경위로.. 무슨 Rust를 만지느냐</h1>\n<p>필자는 보안을 갖다버린 후 Java, Python 이외에는 크게 언어를 만진적이 없다. 심지어 익스또한 파이썬으로 짜기 때문에 읽는 것을 제외하고 작성하는 거셍서는 로우레벨 언어에 대한 애정이 정말 없었다.</p>\n<p>하지만 Runtime Language가 주는 화려한 뒷북은 항상 기가막히게 나의 혈압을 올려왔기에 최근에 핫한 러스트는 야금야금 공부해오고 있었다.</p>\n<p>2023년 중반기 MITS 연구실에 AI 연구원으로 들어가게 되었는데 학슴컴퓨터 발주의 문제(2024 4월에 온단다), Java를 할 줄 안다고 괜히 말했던 필자의 입 문제 등등이 겹쳐 Android기반 초음파 신호처리 개발에 투입되게 되었다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/91e8f331374c5a002d35be2e2099b533/551ac/ultrasound.jpg' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 59.411764705882355%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHMatACB//EABgQAAMBAQAAAAAAAAAAAAAAAAABEQIh/9oACAEBAAEFAk8y5OkIVn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAABBQAAAAAAAAAAAAAAAAAAICFBkbH/2gAIAQEABj8CfCKT/8QAGxAAAwACAwAAAAAAAAAAAAAAAAEREDFBUWH/2gAIAQEAAT8hWiL7hzXFsdE9sdts/9oADAMBAAIAAwAAABBz7//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAAh/9oACAECAQE/EEf/xAAcEAEAAgMAAwAAAAAAAAAAAAABABEhMVEQQZH/2gAIAQEAAT8QFr3yP2VmfTAWZa03jqErtPEEYVD2f//Z'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='초음파이미지' title='' src='/static/91e8f331374c5a002d35be2e2099b533/a22ce/ultrasound.jpg' srcset='/static/91e8f331374c5a002d35be2e2099b533/0b705/ultrasound.jpg 170w,\n/static/91e8f331374c5a002d35be2e2099b533/31389/ultrasound.jpg 340w,\n/static/91e8f331374c5a002d35be2e2099b533/a22ce/ultrasound.jpg 680w,\n/static/91e8f331374c5a002d35be2e2099b533/29373/ultrasound.jpg 1020w,\n/static/91e8f331374c5a002d35be2e2099b533/551ac/ultrasound.jpg 1125w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>초음파이미지</figcaption>\n  </figure><center><em>내가 말한 Java는 분명 Spring을 떠올리고 한 말이였는데...</em></center></p>\n<p>아무튼 그렇게 시작하게 된 Android 신호처리 리팩토링. (짜잔) <br>\n해당 시스템에는 진짜 대단하면서도 간단한 문제가 있었는데... 버벅인다. 버벅버ㅓ겁겁겁걱....</p>\n<p>레거시의 장애사항들을 기반으로 장애원인을 파악해보았다.</p>\n<ol>\n<li>신호처리 로직들이 굵직하게 4가지가 있는데, 해당 부분들은 모두 Vector자료형을 1024x720 픽셀 기준으로 상당히 많은 처리량을 요구한다.</li>\n<li>애초에 JVM 기반 로직 처리량이 그렇게 좋은 편이 아닌데... 너무 무리하게 AP를 갈구고 있었다.</li>\n<li>시리얼 통신, 신호 정규화, 신호 전처리, 송출까지 너무 많은 로직 동기식 수행이 성능이슈를 내고 있었다.</li>\n</ol>\n<p>일단 가장 먼저 제시한건 Server-Side로 전환하는 것. Cuda 기반 병렬 처리나 단순 하드웨어 스케일 업으로 UDP 기반 서버통신으로 신호처리 로직을 이전하자고 하였는데... 교수님이 비 네트워크 환경에서의 웨어러블 고 이식성 초음파 신호처리의 가능성을 검증하고자 하는 프로젝트이기 때문에 안된다고 하셨다.</p>\n<h2>노답인가. 정말 노답인 것인가.</h2>\n<p>Java 레벨에서 쓰레드풀 문제, Android SDK의 잘못된 사용등 모두 고쳐보았으나 약간의 향상 뿐 근본적인 성능 문제는 뿌리 뽑을 수 없었기에 Server-Side 전환이 리젝 된 이상 앞이 참으로 캄캄했다.</p>\n<p>결국 고성능 작업을 처리하는 Android앱의 사례들을 서칭하며 레퍼런스들을 차곡차곡 모았다.\n수많은 최근 작업사례들을 종합적으로 평가해본 결과 최적의 기술을 찾게 되었다.\n<br><br></p>\n<center>러스트 이놈 기가 막힌데요 형님</center>\n<p><img src=\"https://networkstatic.net/wp-content/uploads/2020/01/rustacean-banner.png\"><center><em>귀여운 미래의 간장게장</em></center></p>\n<h3>러스트로 개발하는 케이스는 무엇이 있을까</h3>\n<ol>\n<li>고성능의 작업이 필요할 때 (방대한 리소스)</li>\n<li>빠른 작업처리가 필요할 때 (한정적인 리소스) ⭐️(이것이 필자가 맞이한 상황)⭐️</li>\n<li>임베디드, 안정적이고 경량화된 시스템이 필요할 때</li>\n</ol>\n<p>등등으로 꼽을 수 있는데(서론이 길다..) 빠르고 가볍다는 장점을 사용해야 하는 이런 상황들을 제외하고도 이용할 수 있는 장점으로는 로우레벨 언어의 장점이라고 한다면 ffi 레벨에서 우위를 점할 수 있다는 장점역시 놓칠 수 없다.</p>\n<h2>FFI가 무엇일까</h2>\n<p><img src=\"https://d3i71xaburhd42.cloudfront.net/278bd70d0d53a4f512e8519d30e99e0acfebd3ec/1-Figure1-1.png\"></p>\n<p>필자는 구글링해서 나오는 내용 적는걸 참 싫어하기 때문에 간단히 설명하자면 하이레벨 언어가 로우레벨 언어의 함수를 사용할 수 있는 인터페이스를 제공하는 규격이다.</p>\n<p>각 언어별로 ffi를 지원하는 방식은 각기 다르게 (대부분..?) 지원되고 있으며 예를 들어 Java의 JNI가 있다.</p>\n<p>각 FFI 구현 방식에 따라 조금은 다르지만 일반적으로 <code class=\"language-text\">.dll</code>, <code class=\"language-text\">.dylib</code>, <code class=\"language-text\">.so</code> 확장자로 추출 된 파일을 import 해와서 사용하는 굵직한 방향으로 진행된다.</p>\n<p>참고로 위 파일포맷들은 C, C++에서 공유 라이브러리, 동적 라이브러리라고 불리우는 컴파일 방식에서 얻어낼 수 있는 파일 포맷들로 당연하게도 로우레벨 언어에서 얻어낼 수 있는 공유 라이브러리 포맷이다.</p>\n<h3>짜잔 Rust 등장</h3>\n<p>Rust가 역시나도 위의 세가지 포맷들을 컴파일로서 모두 얻어낼 수 있는데, Samsung의 벤치기반으로 Rus로 작성된 공유 라이브러리의 Android 이식 성능이 꽤 좋은 지표인 걸 알 수 있다.</p>\n<center><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 614px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/01a859ab231b66862f2e3d0148d020ef/c42f5/bench.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 230.00000000000003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAuCAYAAAAoaDnGAAAACXBIWXMAABYlAAAWJQFJUiTwAAAEyklEQVR42o3Xe0/VSQwG4PP1/ZdvwFcgMSQmCIpc5CpgFG8od8UbAoKgOJun5j2ZPbub7Emamc6v03bedjo9g93d3XZ4eDiko6Oj9vHjx/bhw4fh2vHxcdvZ2Sl6//598dZfvHhRfNboGmAuLy/b+fl5+/79e/v69Wvb3Nxsr1+/Hq4bT05Oir58+VLGjJSY7+3ttc+fP9d8wCObTk9PS6GPd+7caRMTE8Vb991mnt+/f7+Nj4+3J0+elJKVlZU2NjbWpqam2qdPn/4ovLi4aN++fWtnZ2dFPKIsa77naHhGEOPZa2R04NwsY7JplHx/9+5dES/w1l++fFkwOKq1whAWv3//bre3t0V+RmtZ93NshL++vi5y5F+/frUfP37USNeAkOg9evSozc/PFzbo+fPnbW5uri0vL9fxr66uinxbWloqDx1TEPGijh/A4ubmprRTzmoi63h4nlKKfv78Wfjxyhie58bBwcFBgRqgzcMLQHhykUUMORk5Xhp9Lwz9eJFfMOxxdRzUy1Da76W4MBQdeQRHGIEgvwhTBgbZQMZmazx7/Phx29/fL0gGyTUpIK+Ev/+NKnQiMozaK1AcooyeAYsADhHwIWliTjhXT7qQ8Q1mjODtFfm6yyKFWLXBnAAeBS9R990aRVIlcvbUXeY2PByZRVigeCCSbgiFlDg6aHJE3uFzmgqKBUn97NmztrW1VXOK1tbWam6Em80wlOwMpDqtr6/Xeil0jB78/spl7pfCERlHZKSXYeRfE5vVJHWSNsU2iW397du3w8Qm7/sAwxqhlKzcUWQtaWPOc+vwpExRAFuu4LA43L17tz18+LA9ePCgMJucnKxiymqOTCGvyKQYUL64uFgJT9fw6rHECg/M4ZLRL8UhsvHUz77h1WMpVbiv2uFTJFT2PBfBUDoFU+uFoSizCBMJmqxPUsfrbEzSI1HG22usKKc4TE9PV3FYWFiovOxTKEFhDIZkOZI8VBzcuMLQQvBAvGBxtDjYbB2Ro5ysU4CFXEU5udUXVxsECzmGteRh8tM33o7m6j9uSu9Zf2P6m5LIwjDfhzcFNqLlQVI4t7e328bGRuViOoi+HpKVd26YNbg9ffq04lCPFKu89MpJcG47CrJZSeoV4vU09tgLQ8rwFZS+HoaS5Ej9kyI2JMWsC4q8NKaGVj10ZVKFbUyd6yt23yzlff7Pip3IYljIy9aXs/7INpPlhH3G5CC+MGRJUgMbdqNPaVoRypxIx5WAgEFAX7169Scoo+9y0mW0t/nf7zLvJCXFuS2jHUS6gr4Yj3YO6S7q6rEQYI2wSmBSsvrehqfpbUQdH0wLQ5ZccAU23Rc88fAKhimwMzMzLY2qQOo6yFXn0BdJVpN3eafTlsRDp0k/mMKCHxaHviVO7iWCPZ9ultLIpyWO99USS9Z40xfPdKkwTf+IeIanIPkYj+mq4vDmzZt6kGZnZ6vAuquKKFxy5BRYXpFz3NwkzYBaMOy+fGBNksLBZvPc89GbkjudKAtM3qO6y0na4BEj6f/w/SOFHF+VyTs+xDAVBfVPKUrl6Z/WzCPT/ysgP+grtAqchpK1dA5GgFvjMU/VSrXTOgP5/U2haq2zWl1dHY4AN1fF7927VxfAmuClqvMuOv4COeOag36jWwwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='bench' title='' src='/static/01a859ab231b66862f2e3d0148d020ef/c42f5/bench.png' srcset='/static/01a859ab231b66862f2e3d0148d020ef/e7570/bench.png 170w,\n/static/01a859ab231b66862f2e3d0148d020ef/f46e7/bench.png 340w,\n/static/01a859ab231b66862f2e3d0148d020ef/c42f5/bench.png 614w' sizes='(max-width: 614px) 100vw, 614px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></center>\n<p>자세히 말하면 삼성이 만든 benchmarksgame-team1 의 Java와 러스트의 성능 비교 자료임.\n일단 벤치만 봐도 근본적인 성능 문제를 해결할 수 있어 보이긴 한다.</p>\n<h2>만들어볼까나</h2>\n<p>일단 중요한 것은 Android에서 FFI를 어떻게 사용하는가. Android SDK 중 일부인 NDK(Native Development Kit)를 사용하여 로우레벨 코드를 사용할 수 있다.</p>\n<p><img src=\"https://www.codeproject.com/KB/android/824711/java-jni-ndk.png\"></p>\n<p>JNI 라는 형식의 인터페이스 컨벤션을 지키면 (각 언어마다 조금 다름) NDK 를 통하여 실핼할 수 있는 환경이 만들어지는데, Rust에서는 아래와 같은 JNI 컨벤션이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">jni<span class=\"token punctuation\">::</span>objects<span class=\"token punctuation\">::</span></span><span class=\"token punctuation\">{</span><span class=\"token class-name\">JClass</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">JString</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//JNI 디펜던시. 각종 타입 포함.</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">jni<span class=\"token punctuation\">::</span>sys<span class=\"token punctuation\">::</span></span>jstring<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">jni<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">JNIEnv</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token attribute attr-name\">#[no_mangle]</span> <span class=\"token comment\">// compiler 가 임의로 함수나 변수의 이름을 변경하지 않도록 함</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"system\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">Java_HelloWorld_hello</span><span class=\"token punctuation\">(</span> \n    <span class=\"token comment\">//Java의 HelloWorld Class에서 hello function 지정. 네이밍 컨벤션임.</span>\n    env<span class=\"token punctuation\">:</span> <span class=\"token class-name\">JNIEnv</span><span class=\"token punctuation\">,</span>\n    _class<span class=\"token punctuation\">:</span> <span class=\"token class-name\">JClass</span><span class=\"token punctuation\">,</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token class-name\">JString</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> jstring <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 이때부터 Rust pure function</span>\n    <span class=\"token keyword\">let</span> input<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span> <span class=\"token operator\">=</span> env<span class=\"token punctuation\">.</span><span class=\"token function\">get_string</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> greeting <span class=\"token operator\">=</span> <span class=\"token macro property\">format!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {input}!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> output <span class=\"token operator\">=</span> env<span class=\"token punctuation\">.</span><span class=\"token function\">new_string</span><span class=\"token punctuation\">(</span>greeting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    output<span class=\"token punctuation\">.</span><span class=\"token function\">into_inner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>참말로 복잡스럽다. 물론 불편함을 감내하고 그냥 때에 맞춰 하나하나 진행하면 될 것만도 같지만 필자의 경우 이런 상황이 너무 싫었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloWorld</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">native</span> <span class=\"token class-name\">String</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// config에서 네이밍을 따로 맞춰주긴 해야한다.</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">loadLibrary</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello_jni\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> output <span class=\"token operator\">=</span> <span class=\"token class-name\">HelloWorld</span><span class=\"token punctuation\">.</span><span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>output<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 문제는 System 패키지에서 load를 진행하고 자체 Class에 계속 호출해가며 함수를 사용한다는 것도 여러개의 라이브러리를 사용하는 상황까지 고려했을 때 차라리 성능저하있는 애플리케이션을 쓰는 것이 정신건강에 나아 보였다.</p>\n<p>CI/CD 인프라를 한번 맛본 사람이 직접 배포하는 환경에서 작업하는 것 만으로도 스트레스가 쌓이듯이 이런 가내수공업식 라이브러리 개발은 정말 지옥이였다.</p>","frontmatter":{"title":"Rust기반 멀티플랫폼 개발기 (1)","date":"January 31, 2024","update":"January 31, 2024","tags":["Rust","개발기"],"series":"Rust 멀티플랫폼 개발"},"fields":{"slug":"/Rust기반 멀티플랫폼 개발기/","readingTime":{"minutes":9.04}}},"seriesList":{"edges":[{"node":{"id":"5615442b-1aa9-5219-8ad5-d1b7b30bc50d","fields":{"slug":"/Rust기반 멀티플랫폼 개발기/"},"frontmatter":{"title":"Rust기반 멀티플랫폼 개발기 (1)"}}}]},"previous":{"fields":{"slug":"/돌고돌아깃헙으로/"},"frontmatter":{"title":"돌고돌아 깃헙으로 😅"}},"next":null},"pageContext":{"id":"5615442b-1aa9-5219-8ad5-d1b7b30bc50d","series":"Rust 멀티플랫폼 개발","previousPostId":"ffedfc92-03a1-5208-bc6e-d373feea65ee","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}